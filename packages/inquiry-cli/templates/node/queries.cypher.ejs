// =============================================================================
// <%= label %> Node CRUD Queries
// <%= description %>
//
// @generated by inquiry-cli
// =============================================================================

// -----------------------------------------------------------------------------
// CREATE
// -----------------------------------------------------------------------------

// Create a new <%= label %> node
// Parameters: { <%= properties.filter(p => p.name !== 'createdAt' && p.name !== 'updatedAt').map(p => p.name).join(', ') %> }
CREATE (n:<%= label %> {
<% for (let i = 0; i < properties.length; i++) { -%>
<% const prop = properties[i]; -%>
<% if (prop.name === 'createdAt' || prop.name === 'updatedAt') { -%>
  <%= prop.name %>: datetime()<%= i < properties.length - 1 ? ',' : '' %>
<% } else if (prop.name === 'id') { -%>
  <%= prop.name %>: $<%= prop.name %><%= i < properties.length - 1 ? ',' : '' %>
<% } else { -%>
  <%= prop.name %>: $<%= prop.name %><%= i < properties.length - 1 ? ',' : '' %>
<% } -%>
<% } -%>
})
RETURN n;

// Create <%= label %> with auto-generated UUID
// Parameters: { <%= properties.filter(p => !['id', 'createdAt', 'updatedAt'].includes(p.name)).map(p => p.name).join(', ') %> }
<% if (withId) { -%>
CREATE (n:<%= label %> {
  id: apoc.create.uuid(),
<% for (let i = 0; i < properties.length; i++) { -%>
<% const prop = properties[i]; -%>
<% if (prop.name === 'id') continue; -%>
<% if (prop.name === 'createdAt' || prop.name === 'updatedAt') { -%>
  <%= prop.name %>: datetime()<%= i < properties.length - 1 ? ',' : '' %>
<% } else { -%>
  <%= prop.name %>: $<%= prop.name %><%= i < properties.length - 1 ? ',' : '' %>
<% } -%>
<% } -%>
})
RETURN n;
<% } -%>

// -----------------------------------------------------------------------------
// READ
// -----------------------------------------------------------------------------

// Find <%= label %> by ID
// Parameters: { id }
<% if (withId) { -%>
MATCH (n:<%= label %> {id: $id})
RETURN n;
<% } -%>

// Find all <%= label %> nodes
MATCH (n:<%= label %>)
RETURN n
ORDER BY n.createdAt DESC;

// Find all <%= label %> nodes with pagination
// Parameters: { skip, limit }
MATCH (n:<%= label %>)
RETURN n
ORDER BY n.createdAt DESC
SKIP $skip
LIMIT $limit;

// Count <%= label %> nodes
MATCH (n:<%= label %>)
RETURN count(n) AS count;

<% for (const prop of properties) { -%>
<% if (prop.indexed && prop.name !== 'id' && prop.name !== 'createdAt') { -%>
// Find <%= label %> by <%= prop.name %>
// Parameters: { <%= prop.name %> }
MATCH (n:<%= label %> {<%= prop.name %>: $<%= prop.name %>})
RETURN n;

<% } -%>
<% } -%>

// Full-text search on <%= label %> (requires index)
// Parameters: { searchTerm }
// CALL db.index.fulltext.queryNodes('<%= label %>FullText', $searchTerm)
// YIELD node, score
// RETURN node, score
// ORDER BY score DESC;

// -----------------------------------------------------------------------------
// UPDATE
// -----------------------------------------------------------------------------

// Update <%= label %> by ID
// Parameters: { id, ...properties to update }
<% if (withId) { -%>
MATCH (n:<%= label %> {id: $id})
SET n += $properties,
    n.updatedAt = datetime()
RETURN n;
<% } -%>

// Update specific properties
// Parameters: { id, <%= properties.filter(p => !['id', 'createdAt', 'updatedAt'].includes(p.name)).map(p => p.name).join(', ') %> }
<% if (withId) { -%>
MATCH (n:<%= label %> {id: $id})
SET
<% const updateProps = properties.filter(p => !['id', 'createdAt', 'updatedAt'].includes(p.name)); -%>
<% for (let i = 0; i < updateProps.length; i++) { -%>
<% const prop = updateProps[i]; -%>
    n.<%= prop.name %> = COALESCE($<%= prop.name %>, n.<%= prop.name %>)<%= i < updateProps.length - 1 ? ',' : ',' %>
<% } -%>
    n.updatedAt = datetime()
RETURN n;
<% } -%>

// -----------------------------------------------------------------------------
// DELETE
// -----------------------------------------------------------------------------

// Delete <%= label %> by ID
// Parameters: { id }
<% if (withId) { -%>
MATCH (n:<%= label %> {id: $id})
DETACH DELETE n
RETURN count(n) AS deleted;
<% } -%>

// Delete all <%= label %> nodes (DANGEROUS - use with caution)
MATCH (n:<%= label %>)
DETACH DELETE n
RETURN count(n) AS deleted;

// Soft delete (set deletedAt timestamp instead of actual deletion)
// Parameters: { id }
<% if (withId) { -%>
MATCH (n:<%= label %> {id: $id})
SET n.deletedAt = datetime(),
    n.updatedAt = datetime()
RETURN n;
<% } -%>

// -----------------------------------------------------------------------------
// RELATIONSHIPS (Templates)
// -----------------------------------------------------------------------------

// Connect <%= label %> to another node
// Parameters: { <%= variableName %>Id, targetId, relationType }
// MATCH (a:<%= label %> {id: $<%= variableName %>Id})
// MATCH (b:TargetLabel {id: $targetId})
// CREATE (a)-[r:RELATES_TO]->(b)
// SET r.createdAt = datetime()
// RETURN a, r, b;

// Find <%= label %> with relationships
// MATCH (n:<%= label %> {id: $id})-[r]-(related)
// RETURN n, r, related;

// -----------------------------------------------------------------------------
// AGGREGATIONS
// -----------------------------------------------------------------------------

// Group <%= label %> by property
<% const groupableProps = properties.filter(p => p.indexed && !['id', 'createdAt', 'updatedAt'].includes(p.name)); -%>
<% if (groupableProps.length > 0) { -%>
<% const firstProp = groupableProps[0]; -%>
// Group by <%= firstProp.name %>
MATCH (n:<%= label %>)
RETURN n.<%= firstProp.name %> AS <%= firstProp.name %>, count(n) AS count
ORDER BY count DESC;
<% } -%>

// Get <%= label %> created in date range
// Parameters: { startDate, endDate }
MATCH (n:<%= label %>)
WHERE n.createdAt >= datetime($startDate)
  AND n.createdAt <= datetime($endDate)
RETURN n
ORDER BY n.createdAt DESC;
