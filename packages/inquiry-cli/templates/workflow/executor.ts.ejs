/**
 * <%= className %> Executor
 * Executes the <%= name %> workflow.
 *
 * @generated by inquiry-cli
 */

import type {
  WorkflowExecution,
  WorkflowContext,
  StepExecution,
  StepContext,
  WorkflowResult,
  StepResult,
  ExecutionError,
  StartWorkflowOptions,
} from '../types/index.js';
import {
  <%= variableName %>Definition,
  <%= variableName %>Steps,
  type <%= classify(name) %>Input,
  type <%= classify(name) %>Output,
} from './<%= name %>.workflow.js';

/**
 * Executor for <%= className %>.
 */
export class <%= className %>Executor {
  private execution: WorkflowExecution | null = null;
  private context: WorkflowContext | null = null;

  /**
   * Starts a new workflow execution.
   */
  async start(
    input: <%= classify(name) %>Input,
    options: StartWorkflowOptions = {}
  ): Promise<WorkflowExecution> {
    const executionId = this.generateId();
    const now = Date.now();

    // Initialize context
    this.context = {
      input: input as unknown as Record<string, unknown>,
      output: {},
      variables: {},
      system: {
        executionId,
        workflowId: <%= variableName %>Definition.id,
        workflowVersion: <%= variableName %>Definition.version,
        startedAt: now,
        currentStepId: null,
      },
      stepResults: {},
    };

    // Initialize execution
    this.execution = {
      id: executionId,
      workflowId: <%= variableName %>Definition.id,
      workflowVersion: <%= variableName %>Definition.version,
      status: 'pending',
      trigger: {
        type: 'api',
        source: options.metadata?.source as string | undefined,
      },
      input: input as unknown as Record<string, unknown>,
      output: {},
      context: this.context,
      currentStepId: null,
      completedStepIds: [],
      runningStepIds: [],
      stepExecutions: {},
      error: null,
      history: [],
      createdAt: now,
      startedAt: null,
      endedAt: null,
      updatedAt: now,
      initiatedBy: options.metadata?.initiatedBy as string | undefined,
      childExecutionIds: [],
      priority: options.priority ?? 1,
      tags: options.tags,
      metadata: options.metadata,
    };

    // Add start event
    this.addEvent('workflow_started', { input });

    return this.execution;
  }

  /**
   * Executes the workflow.
   */
  async execute(): Promise<WorkflowResult> {
    if (!this.execution || !this.context) {
      throw new Error('Workflow not started. Call start() first.');
    }

    const startTime = Date.now();
    this.execution.status = 'running';
    this.execution.startedAt = startTime;

    try {
      // Execute steps
      for (const step of <%= variableName %>Steps) {
        await this.executeStep(step.id);
      }

      // Complete workflow
      this.execution.status = 'completed';
      this.execution.endedAt = Date.now();
      this.execution.output = this.context.output;

      this.addEvent('workflow_completed', {
        output: this.context.output,
        duration: Date.now() - startTime,
      });

      return this.buildResult();
    } catch (error) {
      // Handle failure
      this.execution.status = 'failed';
      this.execution.endedAt = Date.now();
      this.execution.error = this.createError(error);

      this.addEvent('workflow_failed', {
        error: this.execution.error,
        duration: Date.now() - startTime,
      });

      return this.buildResult();
    }
  }

  /**
   * Executes a single step.
   */
  private async executeStep(stepId: string): Promise<StepResult> {
    if (!this.execution || !this.context) {
      throw new Error('Workflow not initialized');
    }

    const step = <%= variableName %>Steps.find((s) => s.id === stepId);
    if (!step) {
      throw new Error(`Step not found: ${stepId}`);
    }

    const stepExecutionId = this.generateId();
    const startTime = Date.now();

    // Create step execution
    const stepExecution: StepExecution = {
      id: stepExecutionId,
      stepId: step.id,
      stepName: step.name,
      stepType: step.type,
      status: 'running',
      input: this.getStepInput(step),
      output: null,
      error: null,
      retryAttempt: 0,
      createdAt: startTime,
      startedAt: startTime,
      endedAt: null,
      durationMs: null,
    };

    this.execution.stepExecutions[stepId] = stepExecution;
    this.execution.currentStepId = stepId;
    this.execution.runningStepIds.push(stepId);

    this.addEvent('step_started', { stepId, stepName: step.name });

    try {
      // Execute based on step type
      const output = await this.executeStepByType(step);

      // Update step execution
      stepExecution.status = 'completed';
      stepExecution.output = output;
      stepExecution.endedAt = Date.now();
      stepExecution.durationMs = Date.now() - startTime;

      // Update context
      this.context.stepResults[stepId] = {
        stepId,
        status: 'completed',
        output,
        error: null,
        startedAt: startTime,
        endedAt: Date.now(),
        durationMs: stepExecution.durationMs,
        retryCount: 0,
      };

      // Apply output mappings
      if (step.outputMappings) {
        for (const mapping of step.outputMappings) {
          this.setContextValue(mapping.target, this.getNestedValue(output, mapping.source));
        }
      }

      // Move to completed
      this.execution.completedStepIds.push(stepId);
      this.execution.runningStepIds = this.execution.runningStepIds.filter((id) => id !== stepId);

      this.addEvent('step_completed', {
        stepId,
        stepName: step.name,
        duration: stepExecution.durationMs,
      });

      return this.context.stepResults[stepId];
    } catch (error) {
      // Handle step failure
      stepExecution.status = 'failed';
      stepExecution.error = this.createError(error);
      stepExecution.endedAt = Date.now();
      stepExecution.durationMs = Date.now() - startTime;

      this.context.stepResults[stepId] = {
        stepId,
        status: 'failed',
        output: null,
        error: stepExecution.error,
        startedAt: startTime,
        endedAt: Date.now(),
        durationMs: stepExecution.durationMs,
        retryCount: stepExecution.retryAttempt,
      };

      this.execution.runningStepIds = this.execution.runningStepIds.filter((id) => id !== stepId);

      this.addEvent('step_failed', {
        stepId,
        stepName: step.name,
        error: stepExecution.error,
      });

      throw error;
    }
  }

  /**
   * Executes a step based on its type.
   */
  private async executeStepByType(step: (typeof <%= variableName %>Steps)[number]): Promise<Record<string, unknown>> {
    switch (step.type) {
      case 'agent':
        return this.executeAgentStep(step);
      case 'sequential':
        return this.executeSequentialStep(step);
      case 'parallel':
        return this.executeParallelStep(step);
      case 'conditional':
        return this.executeConditionalStep(step);
      case 'transform':
        return this.executeTransformStep(step);
      case 'wait':
        return this.executeWaitStep(step);
      default:
        throw new Error(`Unsupported step type: ${(step as { type: string }).type}`);
    }
  }

  /**
   * Executes an agent step.
   */
  private async executeAgentStep(step: { agentId?: string; name: string }): Promise<Record<string, unknown>> {
    // TODO: Integrate with agent registry
    console.log(`Executing agent: ${step.agentId ?? step.name}`);

    // Placeholder - replace with actual agent execution
    return {
      status: 'completed',
      result: { message: `Agent ${step.agentId ?? step.name} executed` },
    };
  }

  /**
   * Executes a sequential step.
   */
  private async executeSequentialStep(step: { steps?: unknown[] }): Promise<Record<string, unknown>> {
    const results: unknown[] = [];

    if (step.steps) {
      for (const childStep of step.steps as Array<{ id: string }>) {
        const result = await this.executeStep(childStep.id);
        results.push(result);
      }
    }

    return { results };
  }

  /**
   * Executes a parallel step.
   */
  private async executeParallelStep(step: { steps?: unknown[] }): Promise<Record<string, unknown>> {
    if (!step.steps || step.steps.length === 0) {
      return { results: [] };
    }

    const promises = (step.steps as Array<{ id: string }>).map((childStep) =>
      this.executeStep(childStep.id)
    );

    const results = await Promise.allSettled(promises);

    return {
      results: results.map((r) => (r.status === 'fulfilled' ? r.value : r.reason)),
    };
  }

  /**
   * Executes a conditional step.
   */
  private async executeConditionalStep(step: {
    condition?: unknown;
    thenStep?: { id: string };
    elseStep?: { id: string };
  }): Promise<Record<string, unknown>> {
    // Evaluate condition - simplified evaluation
    const conditionMet = this.evaluateCondition(step.condition);

    if (conditionMet && step.thenStep) {
      const result = await this.executeStep(step.thenStep.id);
      return result.output ?? { branch: 'then' };
    } else if (!conditionMet && step.elseStep) {
      const result = await this.executeStep(step.elseStep.id);
      return result.output ?? { branch: 'else' };
    }

    return { skipped: true, reason: 'No matching branch' };
  }

  /**
   * Evaluates a condition (TransitionCondition or ConditionGroup).
   */
  private evaluateCondition(condition: unknown): boolean {
    if (!condition) return true;

    // Handle simple field condition (TransitionCondition)
    if (typeof condition === 'object' && condition !== null && 'field' in condition) {
      const cond = condition as { field: string; operator?: string; value?: unknown };
      const fieldValue = this.getContextValue(cond.field);

      // Default to existence check if no operator
      if (!cond.operator || cond.operator === 'exists') {
        return fieldValue !== undefined && fieldValue !== null;
      }

      switch (cond.operator) {
        case 'eq': return fieldValue === cond.value;
        case 'neq': return fieldValue !== cond.value;
        case 'gt': return Number(fieldValue) > Number(cond.value);
        case 'gte': return Number(fieldValue) >= Number(cond.value);
        case 'lt': return Number(fieldValue) < Number(cond.value);
        case 'lte': return Number(fieldValue) <= Number(cond.value);
        case 'isTrue': return fieldValue === true;
        case 'isFalse': return fieldValue === false;
        case 'isEmpty': return !fieldValue || (Array.isArray(fieldValue) && fieldValue.length === 0);
        default: return Boolean(fieldValue);
      }
    }

    // Handle ConditionGroup (logic: 'and' | 'or')
    if (typeof condition === 'object' && condition !== null && 'logic' in condition) {
      const group = condition as { logic: 'and' | 'or'; conditions: unknown[] };
      if (group.logic === 'and') {
        return group.conditions.every((c) => this.evaluateCondition(c));
      } else {
        return group.conditions.some((c) => this.evaluateCondition(c));
      }
    }

    // Default: truthy check
    return Boolean(condition);
  }

  /**
   * Executes a transform step.
   */
  private async executeTransformStep(step: {
    inputVariable?: string;
    outputVariable?: string;
    expression?: string;
  }): Promise<Record<string, unknown>> {
    const input = step.inputVariable
      ? this.getContextValue(step.inputVariable)
      : this.context?.input;

    // Simple pass-through for now
    const output = input;

    if (step.outputVariable) {
      this.setContextValue(step.outputVariable, output);
    }

    return { transformed: output };
  }

  /**
   * Executes a wait step.
   */
  private async executeWaitStep(step: { durationMs?: number }): Promise<Record<string, unknown>> {
    const duration = step.durationMs ?? 0;

    if (duration > 0) {
      await new Promise((resolve) => setTimeout(resolve, duration));
    }

    return { waited: duration };
  }

  /**
   * Gets input for a step based on mappings.
   */
  private getStepInput(step: { inputMappings?: Array<{ source: string; target: string }> }): Record<string, unknown> {
    const input: Record<string, unknown> = {};

    if (step.inputMappings && this.context) {
      for (const mapping of step.inputMappings) {
        const value = this.getContextValue(mapping.source);
        this.setNestedValue(input, mapping.target, value);
      }
    }

    return input;
  }

  /**
   * Gets a value from the workflow context.
   */
  private getContextValue(path: string): unknown {
    if (!this.context) return undefined;

    if (path === 'input') return this.context.input;
    if (path === 'output') return this.context.output;
    if (path.startsWith('input.')) return this.getNestedValue(this.context.input, path.slice(6));
    if (path.startsWith('output.')) return this.getNestedValue(this.context.output, path.slice(7));
    if (path.startsWith('variables.')) return this.getNestedValue(this.context.variables, path.slice(10));
    if (path.startsWith('steps.')) return this.getNestedValue(this.context.stepResults, path.slice(6));

    return this.getNestedValue(this.context.variables, path);
  }

  /**
   * Sets a value in the workflow context.
   */
  private setContextValue(path: string, value: unknown): void {
    if (!this.context) return;

    if (path.startsWith('output.')) {
      this.setNestedValue(this.context.output, path.slice(7), value);
    } else if (path.startsWith('variables.')) {
      this.setNestedValue(this.context.variables, path.slice(10), value);
    } else if (path.startsWith('steps.')) {
      this.setNestedValue(this.context.stepResults as Record<string, unknown>, path.slice(6), value);
    } else {
      this.setNestedValue(this.context.variables, path, value);
    }
  }

  /**
   * Gets a nested value from an object.
   */
  private getNestedValue(obj: unknown, path: string): unknown {
    return path.split('.').reduce((current, key) => {
      if (current && typeof current === 'object' && key in current) {
        return (current as Record<string, unknown>)[key];
      }
      return undefined;
    }, obj);
  }

  /**
   * Sets a nested value in an object.
   */
  private setNestedValue(obj: Record<string, unknown>, path: string, value: unknown): void {
    const keys = path.split('.');
    const lastKey = keys.pop();
    if (!lastKey) return;

    let current = obj;
    for (const key of keys) {
      if (!(key in current) || typeof current[key] !== 'object') {
        current[key] = {};
      }
      current = current[key] as Record<string, unknown>;
    }

    current[lastKey] = value;
  }

  /**
   * Adds an event to the execution history.
   */
  private addEvent(
    type: string,
    data: Record<string, unknown>
  ): void {
    if (!this.execution) return;

    this.execution.history.push({
      id: this.generateId(),
      timestamp: Date.now(),
      type: type as 'workflow_started',
      data,
      severity: type.includes('failed') || type.includes('error') ? 'error' : 'info',
    });

    this.execution.updatedAt = Date.now();
  }

  /**
   * Creates an execution error from an unknown error.
   */
  private createError(error: unknown): ExecutionError {
    if (error instanceof Error) {
      return {
        code: 'EXECUTION_ERROR',
        message: error.message,
        type: 'system',
        stack: error.stack,
        retryable: true,
      };
    }

    return {
      code: 'UNKNOWN_ERROR',
      message: String(error),
      type: 'system',
      retryable: false,
    };
  }

  /**
   * Builds the workflow result.
   */
  private buildResult(): WorkflowResult {
    if (!this.execution || !this.context) {
      throw new Error('Workflow not initialized');
    }

    const endedAt = this.execution.endedAt ?? Date.now();
    const startedAt = this.execution.startedAt ?? this.execution.createdAt;

    return {
      executionId: this.execution.id,
      status: this.execution.status,
      output: this.execution.output,
      error: this.execution.error,
      stepResults: this.context.stepResults,
      startedAt,
      endedAt,
      durationMs: Number(endedAt) - Number(startedAt),
      metrics: {
        stepsExecuted: Object.keys(this.context.stepResults).length,
        stepsCompleted: this.execution.completedStepIds.length,
        stepsFailed: Object.values(this.context.stepResults).filter((r) => r.status === 'failed').length,
        stepsSkipped: Object.values(this.context.stepResults).filter((r) => r.status === 'skipped').length,
        totalRetries: 0,
        totalApiCalls: 0,
        totalTokensUsed: 0,
      },
    };
  }

  /**
   * Generates a unique ID.
   */
  private generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).slice(2, 11)}`;
  }

  /**
   * Gets the current execution state.
   */
  getExecution(): WorkflowExecution | null {
    return this.execution;
  }

  /**
   * Gets the current context.
   */
  getContext(): WorkflowContext | null {
    return this.context;
  }
}

/**
 * Executes the <%= className %> workflow.
 */
export async function execute<%= classify(name) %>(
  input: <%= classify(name) %>Input,
  options: StartWorkflowOptions = {}
): Promise<WorkflowResult> {
  const executor = new <%= className %>Executor();
  await executor.start(input, options);
  return executor.execute();
}
